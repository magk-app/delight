# Story 3.1: Create Goal Data Models and CRUD APIs

**Story ID:** 3.1
**Epic:** 3 - Goal & Mission Management
**Status:** drafted
**Priority:** P0 (Core Productivity Loop)
**Estimated Effort:** 8-10 hours
**Assignee:** Claude Dev Agent
**Created:** 2025-11-18
**Updated:** 2025-11-18

---

## User Story

**As a** user,
**I want** to create and manage long-term goals,
**So that** I have a clear vision of what I'm working toward.

---

## Context

### Problem Statement

The Goal & Mission Management system (Epic 3) enables users to transform overwhelming ambitions into achievable daily actions. Story 3.1 establishes the foundation by creating goal models and CRUD APIs that allow users to define their aspirations in a structured way.

Goals in Delight are more than simple todo items - they represent meaningful long-term ambitions across different value categories (health, craft, growth, connection). This story creates the data layer and basic API operations that subsequent stories will build upon for goal decomposition, mission generation, and progress tracking.

### Why This Approach?

**From Architecture (ARCHITECTURE.md):**

The goal system uses PostgreSQL for structured data storage with:
- ✅ **UUID Primary Keys**: Generated by PostgreSQL `gen_random_uuid()` for distributed systems compatibility
- ✅ **JSONB Flexibility**: Allows future extensibility without schema migrations
- ✅ **Foreign Key Integrity**: Ensures goals are properly linked to authenticated users
- ✅ **Timestamps with Timezone**: Consistent time tracking across user locations

**From Epic Breakdown (epics.md lines 640-682):**

Goals have two critical attributes:
- **Goal Type**: Abstract (e.g., "Be healthier") vs. Concrete (e.g., "Run a marathon by June")
- **Value Category**: Aligns with universal factors (health, craft, growth, connection)

This classification enables:
- Story 3.2: Collaborative decomposition strategies differ by goal type
- Story 3.3: Mission prioritization balances value category diversity
- Epic 5: Progress analytics track which values users actively pursue

### Dependencies

- **Prerequisite Stories:**
  - 1.2 (Database Schema and Migrations) ✅ Complete - Alembic configured, migrations working
  - 1.3 (Clerk Authentication) ✅ Complete - User authentication established

- **Epic 3 Context:** This story **enables**:
  - Story 3.2: Goal decomposition requires existing goal records to decompose
  - Story 3.3: Mission/quest system links missions to parent goals via `goal_id` FK
  - Epic 5: Progress tracking analyzes goal completion patterns

- **External Dependencies:**
  - Supabase database connection established (DATABASE_URL environment variable)
  - Clerk authentication middleware configured (`clerk_user_id` available in requests)

### Technical Background

**Value Categories (from Product Brief):**

The four core value categories map to universal human needs:

1. **Health**: Physical and mental well-being (exercise, nutrition, sleep, therapy)
2. **Craft**: Creative expression and skill mastery (art, music, writing, building)
3. **Growth**: Learning and intellectual development (courses, reading, certifications)
4. **Connection**: Relationships and community (family, friends, networking, mentoring)

**Goal Types:**

- **Abstract**: Broad aspirations requiring decomposition ("Be more confident", "Improve relationships")
- **Concrete**: Specific, measurable objectives ("Graduate by May 2026", "Run 5k under 30 minutes")

Abstract goals benefit more from Eliza's collaborative decomposition (Story 3.2), while concrete goals can be directly translated into missions.

---

## Acceptance Criteria

### AC1: Goal Model Exists with Required Fields

**Given** the database migration is applied
**When** I inspect the database schema
**Then** a `goals` table exists with the following columns:

- `id` (UUID, primary key, default `gen_random_uuid()`)
- `user_id` (UUID, foreign key to `users.id`, not null)
- `title` (VARCHAR(200), not null)
- `description` (TEXT, nullable)
- `goal_type` (VARCHAR(20), not null, CHECK constraint: `abstract` or `concrete`)
- `value_category` (VARCHAR(50), not null, CHECK constraint: `health`, `craft`, `growth`, `connection`)
- `target_date` (DATE, nullable)
- `status` (VARCHAR(20), not null, default `active`, CHECK constraint: `active`, `paused`, `completed`, `archived`)
- `created_at` (TIMESTAMP WITH TIME ZONE, not null, default `NOW()`)
- `updated_at` (TIMESTAMP WITH TIME ZONE, not null, default `NOW()`)

**And** a database index exists on `(user_id, status)` for efficient filtering

**Verification Steps:**

```bash
# Connect to database and inspect schema
psql $DATABASE_URL -c "\d goals"

# Verify constraints
SELECT constraint_name, constraint_type
FROM information_schema.table_constraints
WHERE table_name = 'goals';
```

### AC2: Create Goal API Endpoint Works

**Given** I'm authenticated with Clerk
**When** I POST to `/api/v1/goals` with goal data
**Then** a new goal is created and returned with:

- Generated UUID `id`
- My `user_id` (extracted from Clerk auth token)
- All provided fields (title, description, goal_type, value_category, target_date)
- Default `status` of `active`
- Timestamps `created_at` and `updated_at` set to current time

**And** the response status is `201 Created`

**Request Example:**
```json
POST /api/v1/goals
Authorization: Bearer <clerk_session_token>
Content-Type: application/json

{
  "title": "Graduate early from Georgia Tech",
  "description": "Complete my CS degree by May 2026 instead of December 2026",
  "goal_type": "concrete",
  "value_category": "growth",
  "target_date": "2026-05-15"
}
```

**Response Example:**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "user_id": "user_2abc123xyz",
  "title": "Graduate early from Georgia Tech",
  "description": "Complete my CS degree by May 2026 instead of December 2026",
  "goal_type": "concrete",
  "value_category": "growth",
  "target_date": "2026-05-15",
  "status": "active",
  "created_at": "2025-11-18T10:30:00Z",
  "updated_at": "2025-11-18T10:30:00Z"
}
```

### AC3: List Goals API Endpoint Works

**Given** I have created multiple goals
**When** I GET `/api/v1/goals`
**Then** I receive a list of all my goals (filtered by my `user_id`)

**And** I can filter by status: `GET /api/v1/goals?status=active`

**And** goals are sorted by `created_at` descending (newest first) by default

**And** the response includes pagination metadata

**Verification Steps:**

```bash
# List all my goals
curl -H "Authorization: Bearer $CLERK_TOKEN" \
  http://localhost:8000/api/v1/goals

# List only active goals
curl -H "Authorization: Bearer $CLERK_TOKEN" \
  "http://localhost:8000/api/v1/goals?status=active"
```

### AC4: Get Single Goal API Endpoint Works

**Given** I have created a goal
**When** I GET `/api/v1/goals/{id}`
**Then** I receive the complete goal details

**And** if the goal doesn't exist or belongs to another user, I receive `404 Not Found`

**Verification Steps:**

```bash
# Get specific goal
curl -H "Authorization: Bearer $CLERK_TOKEN" \
  http://localhost:8000/api/v1/goals/550e8400-e29b-41d4-a716-446655440000

# Try to access another user's goal (should return 404)
curl -H "Authorization: Bearer $CLERK_TOKEN" \
  http://localhost:8000/api/v1/goals/invalid-or-other-users-id
```

### AC5: Update Goal API Endpoint Works

**Given** I have created a goal
**When** I PATCH `/api/v1/goals/{id}` with updated fields
**Then** the goal is updated with the new values

**And** `updated_at` timestamp is automatically refreshed

**And** only the provided fields are updated (partial update support)

**And** I cannot update `id`, `user_id`, or `created_at` (read-only fields)

**Request Example:**
```json
PATCH /api/v1/goals/550e8400-e29b-41d4-a716-446655440000
Authorization: Bearer <clerk_session_token>
Content-Type: application/json

{
  "status": "paused",
  "description": "Pausing temporarily due to internship commitments"
}
```

### AC6: Archive Goal API Endpoint Works (Soft Delete)

**Given** I have created a goal
**When** I DELETE `/api/v1/goals/{id}`
**Then** the goal's `status` is changed to `archived` (soft delete)

**And** `updated_at` timestamp is refreshed

**And** the goal remains in the database (not permanently deleted)

**And** archived goals are excluded from default list queries (unless `status=archived` specified)

**Note:** We use soft delete to preserve goal history for analytics and potential restoration.

### AC7: Goal Validation Works Correctly

**Given** I attempt to create or update a goal
**When** I provide invalid data
**Then** I receive a `422 Unprocessable Entity` error with validation details

**Validation Rules:**
- `title`: Required, max 200 characters, non-empty
- `goal_type`: Required, must be `abstract` or `concrete`
- `value_category`: Required, must be `health`, `craft`, `growth`, or `connection`
- `target_date`: Optional, must be valid date format (YYYY-MM-DD), can be in past (for retroactive goals)
- `status`: Must be `active`, `paused`, `completed`, or `archived`
- `description`: Optional, max 2000 characters

**Test Invalid Requests:**

```bash
# Missing required field
curl -X POST http://localhost:8000/api/v1/goals \
  -H "Authorization: Bearer $CLERK_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"description": "No title provided"}'
# Expected: 422 error, "title is required"

# Invalid goal_type
curl -X POST http://localhost:8000/api/v1/goals \
  -H "Authorization: Bearer $CLERK_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"title": "Test", "goal_type": "invalid", "value_category": "health"}'
# Expected: 422 error, "goal_type must be abstract or concrete"
```

### AC8: Authorization Works Correctly

**Given** I'm an authenticated user
**When** I attempt to access goal endpoints
**Then** I can only view/modify my own goals (filtered by `user_id` from Clerk token)

**And** attempting to access another user's goal returns `404 Not Found` (not `403 Forbidden` to prevent information disclosure)

**And** unauthenticated requests return `401 Unauthorized`

**Security Tests:**

```bash
# No auth token
curl http://localhost:8000/api/v1/goals
# Expected: 401 Unauthorized

# Invalid token
curl -H "Authorization: Bearer invalid_token" \
  http://localhost:8000/api/v1/goals
# Expected: 401 Unauthorized

# Try to update another user's goal (should fail silently with 404)
# This requires knowing another user's goal ID, which shouldn't be possible
# through normal API usage due to filtering
```

---

## Tasks / Subtasks

### Task 1: Create Database Migration (AC: #1)

- [ ] **1.1** Create new Alembic migration: `alembic revision -m "create goals table"`
- [ ] **1.2** Define `goals` table schema in migration file:
  - UUID id with `gen_random_uuid()` default
  - Foreign key to `users(id)` with CASCADE delete
  - All required columns with appropriate types
  - CHECK constraints for enums (goal_type, value_category, status)
  - NOT NULL constraints where appropriate
  - Default values (status = 'active', timestamps)
- [ ] **1.3** Add index: `CREATE INDEX idx_goals_user_status ON goals(user_id, status)`
- [ ] **1.4** Add trigger for auto-updating `updated_at` timestamp:
  ```sql
  CREATE TRIGGER update_goals_updated_at
    BEFORE UPDATE ON goals
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
  ```
- [ ] **1.5** Apply migration: `alembic upgrade head`
- [ ] **1.6** Verify table created: `psql $DATABASE_URL -c "\d goals"`

### Task 2: Create SQLAlchemy Model (AC: #1)

- [ ] **2.1** Create `packages/backend/app/models/goal.py`
- [ ] **2.2** Define `Goal` model class:
  ```python
  from sqlalchemy import Column, String, Text, Date, DateTime, Enum as SQLEnum, ForeignKey
  from sqlalchemy.dialects.postgresql import UUID
  from sqlalchemy.orm import relationship
  from app.models.base import Base
  import enum
  import uuid
  from datetime import datetime

  class GoalType(str, enum.Enum):
      ABSTRACT = "abstract"
      CONCRETE = "concrete"

  class ValueCategory(str, enum.Enum):
      HEALTH = "health"
      CRAFT = "craft"
      GROWTH = "growth"
      CONNECTION = "connection"

  class GoalStatus(str, enum.Enum):
      ACTIVE = "active"
      PAUSED = "paused"
      COMPLETED = "completed"
      ARCHIVED = "archived"

  class Goal(Base):
      __tablename__ = "goals"

      id = Column(UUID(as_uuid=True), primary_key=True, server_default=text("gen_random_uuid()"))
      user_id = Column(String, ForeignKey("users.clerk_user_id", ondelete="CASCADE"), nullable=False)
      title = Column(String(200), nullable=False)
      description = Column(Text, nullable=True)
      goal_type = Column(SQLEnum(GoalType), nullable=False)
      value_category = Column(SQLEnum(ValueCategory), nullable=False)
      target_date = Column(Date, nullable=True)
      status = Column(SQLEnum(GoalStatus), nullable=False, server_default="active")
      created_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now())
      updated_at = Column(DateTime(timezone=True), nullable=False, server_default=func.now(), onupdate=func.now())

      # Relationships (will be used in future stories)
      user = relationship("User", back_populates="goals")
      missions = relationship("Mission", back_populates="goal", cascade="all, delete-orphan")
  ```
- [ ] **2.3** Update `app/models/__init__.py` to import Goal model
- [ ] **2.4** Update `User` model to add `goals` relationship

### Task 3: Create Pydantic Schemas (AC: #2-#8)

- [ ] **3.1** Create `packages/backend/app/schemas/goal.py`
- [ ] **3.2** Define request/response schemas:
  ```python
  from pydantic import BaseModel, Field, validator
  from typing import Optional
  from datetime import date, datetime
  from app.models.goal import GoalType, ValueCategory, GoalStatus
  import uuid

  class GoalBase(BaseModel):
      title: str = Field(..., min_length=1, max_length=200, description="Goal title")
      description: Optional[str] = Field(None, max_length=2000, description="Detailed description")
      goal_type: GoalType = Field(..., description="Abstract or concrete goal")
      value_category: ValueCategory = Field(..., description="Primary value category")
      target_date: Optional[date] = Field(None, description="Target completion date")

  class GoalCreate(GoalBase):
      pass

  class GoalUpdate(BaseModel):
      title: Optional[str] = Field(None, min_length=1, max_length=200)
      description: Optional[str] = Field(None, max_length=2000)
      goal_type: Optional[GoalType] = None
      value_category: Optional[ValueCategory] = None
      target_date: Optional[date] = None
      status: Optional[GoalStatus] = None

  class GoalResponse(GoalBase):
      id: uuid.UUID
      user_id: str
      status: GoalStatus
      created_at: datetime
      updated_at: datetime

      class Config:
          from_attributes = True

  class GoalListResponse(BaseModel):
      goals: list[GoalResponse]
      total: int
      page: int = 1
      page_size: int = 50
  ```
- [ ] **3.3** Add validators for business rules (if any)

### Task 4: Create Goal Service (AC: #2-#8)

- [ ] **4.1** Create `packages/backend/app/services/goal_service.py`
- [ ] **4.2** Implement `GoalService` class with async methods:
  ```python
  from sqlalchemy.ext.asyncio import AsyncSession
  from sqlalchemy import select, and_
  from app.models.goal import Goal, GoalStatus
  from app.schemas.goal import GoalCreate, GoalUpdate
  from typing import Optional
  import uuid

  class GoalService:
      def __init__(self, db: AsyncSession):
          self.db = db

      async def create_goal(self, user_id: str, goal_data: GoalCreate) -> Goal:
          """Create a new goal for the user."""
          goal = Goal(user_id=user_id, **goal_data.model_dump())
          self.db.add(goal)
          await self.db.commit()
          await self.db.refresh(goal)
          return goal

      async def get_user_goals(
          self,
          user_id: str,
          status: Optional[GoalStatus] = None,
          skip: int = 0,
          limit: int = 50
      ) -> tuple[list[Goal], int]:
          """Get user's goals with optional status filter."""
          filters = [Goal.user_id == user_id]
          if status:
              filters.append(Goal.status == status)

          query = select(Goal).where(and_(*filters)).order_by(Goal.created_at.desc())
          count_query = select(func.count(Goal.id)).where(and_(*filters))

          result = await self.db.execute(query.offset(skip).limit(limit))
          goals = result.scalars().all()

          count_result = await self.db.execute(count_query)
          total = count_result.scalar()

          return goals, total

      async def get_goal_by_id(self, user_id: str, goal_id: uuid.UUID) -> Optional[Goal]:
          """Get a specific goal (ensuring it belongs to the user)."""
          result = await self.db.execute(
              select(Goal).where(and_(Goal.id == goal_id, Goal.user_id == user_id))
          )
          return result.scalar_one_or_none()

      async def update_goal(
          self, user_id: str, goal_id: uuid.UUID, goal_data: GoalUpdate
      ) -> Optional[Goal]:
          """Update a goal (partial update)."""
          goal = await self.get_goal_by_id(user_id, goal_id)
          if not goal:
              return None

          update_data = goal_data.model_dump(exclude_unset=True)
          for field, value in update_data.items():
              setattr(goal, field, value)

          await self.db.commit()
          await self.db.refresh(goal)
          return goal

      async def archive_goal(self, user_id: str, goal_id: uuid.UUID) -> Optional[Goal]:
          """Archive a goal (soft delete)."""
          goal = await self.get_goal_by_id(user_id, goal_id)
          if not goal:
              return None

          goal.status = GoalStatus.ARCHIVED
          await self.db.commit()
          await self.db.refresh(goal)
          return goal
  ```

### Task 5: Create API Endpoints (AC: #2-#8)

- [ ] **5.1** Create `packages/backend/app/api/v1/goals.py`
- [ ] **5.2** Implement CRUD endpoints with Clerk authentication:
  ```python
  from fastapi import APIRouter, Depends, HTTPException, Query
  from sqlalchemy.ext.asyncio import AsyncSession
  from app.api.deps import get_current_user, get_db
  from app.services.goal_service import GoalService
  from app.schemas.goal import GoalCreate, GoalUpdate, GoalResponse, GoalListResponse
  from app.models.goal import GoalStatus
  from typing import Optional
  import uuid

  router = APIRouter(prefix="/goals", tags=["goals"])

  @router.post("", response_model=GoalResponse, status_code=201)
  async def create_goal(
      goal_data: GoalCreate,
      current_user: dict = Depends(get_current_user),
      db: AsyncSession = Depends(get_db)
  ):
      """Create a new goal."""
      service = GoalService(db)
      goal = await service.create_goal(current_user["user_id"], goal_data)
      return goal

  @router.get("", response_model=GoalListResponse)
  async def list_goals(
      status: Optional[GoalStatus] = Query(None, description="Filter by status"),
      page: int = Query(1, ge=1),
      page_size: int = Query(50, ge=1, le=100),
      current_user: dict = Depends(get_current_user),
      db: AsyncSession = Depends(get_db)
  ):
      """List user's goals with optional filters."""
      service = GoalService(db)
      skip = (page - 1) * page_size
      goals, total = await service.get_user_goals(
          current_user["user_id"], status, skip, page_size
      )
      return GoalListResponse(goals=goals, total=total, page=page, page_size=page_size)

  @router.get("/{goal_id}", response_model=GoalResponse)
  async def get_goal(
      goal_id: uuid.UUID,
      current_user: dict = Depends(get_current_user),
      db: AsyncSession = Depends(get_db)
  ):
      """Get a specific goal."""
      service = GoalService(db)
      goal = await service.get_goal_by_id(current_user["user_id"], goal_id)
      if not goal:
          raise HTTPException(status_code=404, detail="Goal not found")
      return goal

  @router.patch("/{goal_id}", response_model=GoalResponse)
  async def update_goal(
      goal_id: uuid.UUID,
      goal_data: GoalUpdate,
      current_user: dict = Depends(get_current_user),
      db: AsyncSession = Depends(get_db)
  ):
      """Update a goal (partial update)."""
      service = GoalService(db)
      goal = await service.update_goal(current_user["user_id"], goal_id, goal_data)
      if not goal:
          raise HTTPException(status_code=404, detail="Goal not found")
      return goal

  @router.delete("/{goal_id}", response_model=GoalResponse)
  async def archive_goal(
      goal_id: uuid.UUID,
      current_user: dict = Depends(get_current_user),
      db: AsyncSession = Depends(get_db)
  ):
      """Archive a goal (soft delete)."""
      service = GoalService(db)
      goal = await service.archive_goal(current_user["user_id"], goal_id)
      if not goal:
          raise HTTPException(status_code=404, detail="Goal not found")
      return goal
  ```
- [ ] **5.3** Register router in `app/api/v1/__init__.py`
- [ ] **5.4** Update `app/main.py` to include goals router

### Task 6: Create Unit Tests (AC: All)

- [ ] **6.1** Create `packages/backend/tests/services/test_goal_service.py`
- [ ] **6.2** Test `GoalService` methods:
  - `test_create_goal()`: Creates goal with correct fields
  - `test_get_user_goals()`: Filters by user_id correctly
  - `test_get_user_goals_with_status_filter()`: Status filtering works
  - `test_get_goal_by_id()`: Retrieves correct goal
  - `test_get_goal_by_id_wrong_user()`: Returns None for other user's goal
  - `test_update_goal()`: Updates specified fields only
  - `test_update_goal_refreshes_timestamp()`: `updated_at` changes
  - `test_archive_goal()`: Sets status to archived
- [ ] **6.3** Use pytest fixtures for database sessions
- [ ] **6.4** Target: 80%+ test coverage for `GoalService`

### Task 7: Create Integration Tests (AC: #2-#8)

- [ ] **7.1** Create `packages/backend/tests/api/test_goals_api.py`
- [ ] **7.2** Test API endpoints end-to-end:
  - `test_create_goal_success()`: POST creates goal and returns 201
  - `test_create_goal_missing_field()`: Returns 422 validation error
  - `test_create_goal_invalid_goal_type()`: Returns 422 for invalid enum
  - `test_list_goals()`: GET returns user's goals only
  - `test_list_goals_with_status_filter()`: Status filter works
  - `test_get_goal()`: GET by ID returns correct goal
  - `test_get_goal_not_found()`: Returns 404 for non-existent ID
  - `test_get_goal_other_user()`: Returns 404 for other user's goal (not 403)
  - `test_update_goal()`: PATCH updates fields correctly
  - `test_update_goal_partial()`: Partial update works (only provided fields)
  - `test_archive_goal()`: DELETE soft-deletes (status = archived)
  - `test_unauthorized_access()`: Returns 401 without auth token
- [ ] **7.3** Mock Clerk authentication in tests
- [ ] **7.4** Use test database (not production)
- [ ] **7.5** Clean up test data after each test

### Task 8: Documentation and API Examples (AC: All)

- [ ] **8.1** Add docstrings to all `GoalService` methods
- [ ] **8.2** Add OpenAPI descriptions to all API endpoints (FastAPI automatic docs)
- [ ] **8.3** Update `docs/API-TESTING-GUIDE.md` with goal endpoints:
  - Example requests for each endpoint
  - Response examples
  - Common error scenarios
- [ ] **8.4** Document value categories and goal types in code comments
- [ ] **8.5** Add example curl commands to story documentation

---

## Dev Notes

### Goal System Design Principles

**From Product Brief:**

Goals in Delight serve as anchors for mission generation and progress tracking. The system must:

1. **Support Both Abstract and Concrete Goals**: Users think about goals differently
   - Abstract: "Be more confident in social situations" → requires decomposition
   - Concrete: "Run a half-marathon by June" → directly translatable to missions

2. **Align with Value Categories**: Universal factors help balance user progress
   - Health: Physical and mental well-being
   - Craft: Creative expression and skill mastery
   - Growth: Learning and intellectual development
   - Connection: Relationships and community

3. **Enable Soft Delete**: Preserve goal history for:
   - Epic 5: Progress analytics need historical data
   - Future: User might want to restore archived goals
   - Auditing: Understand user journey over time

### Database Design Notes

**PostgreSQL UUID Generation:**

We use PostgreSQL's `gen_random_uuid()` instead of application-level UUID generation because:
- ✅ Guaranteed uniqueness at database level
- ✅ Supports database replication scenarios
- ✅ Consistent with Story 1.2 database schema patterns

**Foreign Key Cascade:**

`user_id` has `ON DELETE CASCADE` to ensure orphaned goals are cleaned up if a user account is deleted. This is important for:
- GDPR compliance (right to be forgotten)
- Database consistency
- Preventing orphaned records

**Index Strategy:**

The `(user_id, status)` composite index optimizes the most common query pattern:
```sql
SELECT * FROM goals WHERE user_id = ? AND status = 'active' ORDER BY created_at DESC;
```

This query will be used frequently in Story 3.3 (mission triads) to find active goals for mission generation.

### Value Category Future Extensions

**From Architecture Discussion:**

While MVP has 4 core categories, the system is designed to support extended categories:
- **Well-being**: Overall life satisfaction (might combine health + connection)
- **Achievement**: Accomplishments and milestones (might be implicit in all goals)
- **Discipline**: Self-control and consistency (cross-cutting concern)

We use VARCHAR(50) instead of ENUM to allow future category additions without schema migrations. The CHECK constraint in the migration file can be updated via migration if needed.

### Goal Type Decomposition Strategy (Preview of Story 3.2)

**Abstract Goal Example:**
```
Goal: "Be more confident in social situations"
↓ Decomposition (Story 3.2)
Milestones:
1. Understand current confidence blockers
2. Practice small social interactions
3. Build comfort with larger groups
4. Establish regular social habits
↓ Mission Generation (Story 3.3)
Missions:
- "Journal about recent social anxiety triggers" (10 min)
- "Say hello to one new person today" (5 min)
- "Attend coffee meetup" (1 hour)
```

**Concrete Goal Example:**
```
Goal: "Run half-marathon by June 15, 2026"
↓ Direct Mission Generation (Story 3.3)
Missions:
- "Run 2 miles at easy pace" (30 min)
- "Complete long run: 6 miles" (1 hour)
- "Cross-training: strength workout" (45 min)
```

### API Design Decisions

**Soft Delete vs. Hard Delete:**

We implement soft delete (`status = archived`) instead of physical deletion because:
- ✅ Preserves data for Epic 5 analytics
- ✅ Allows potential "unarchive" feature in future
- ✅ Maintains foreign key relationships for historical missions
- ✅ Supports audit trails and user journey analysis

**Pagination:**

Default pagination (page=1, page_size=50) is included even though MVP users might have <10 goals. This prevents future scaling issues and follows best practices from Story 1.2 architecture.

**Authorization Strategy:**

We return `404 Not Found` instead of `403 Forbidden` when a user tries to access another user's goal. This prevents information disclosure (confirming existence of goal IDs).

### Integration with Future Stories

**Story 3.2 (Goal Decomposition):**
- Will read `goal_type` to determine decomposition strategy
- Will create `goal_decompositions` table linked to goals via `goal_id` FK
- Will store Eliza's proposed milestones and user's approved missions

**Story 3.3 (Mission System):**
- Missions table will have `goal_id` FK linking to this goals table
- Mission prioritization algorithm will consider `value_category` for diversity
- Mission triads will show `target_date` to communicate urgency

**Epic 5 (Progress Analytics):**
- Will query goals by `value_category` to show progress distribution
- Will analyze `created_at` vs. `target_date` for goal velocity metrics
- Will track completion rates by goal_type (abstract vs. concrete)

### Testing Strategy

**Unit Tests:**
- Focus on `GoalService` business logic
- Mock database session
- Test edge cases (invalid IDs, wrong user, etc.)

**Integration Tests:**
- End-to-end API testing with real database (test database)
- Mock Clerk authentication (avoid external API calls)
- Test authorization boundaries thoroughly

**Manual Testing Checklist:**
- [ ] Create goal via Swagger UI (http://localhost:8000/docs)
- [ ] Verify goal appears in database: `SELECT * FROM goals;`
- [ ] Test all CRUD operations via curl or Postman
- [ ] Verify timestamps update correctly on PATCH
- [ ] Confirm soft delete (archived goals still in DB)
- [ ] Test validation errors return 422 with helpful messages
- [ ] Confirm unauthorized requests return 401

### Project Structure Notes

**New Files Created:**
```
packages/backend/
├── app/
│   ├── models/
│   │   └── goal.py                  # NEW: Goal SQLAlchemy model
│   ├── schemas/
│   │   └── goal.py                  # NEW: Pydantic request/response schemas
│   ├── services/
│   │   └── goal_service.py          # NEW: Goal business logic
│   └── api/
│       └── v1/
│           └── goals.py             # NEW: Goal CRUD endpoints
├── tests/
│   ├── services/
│   │   └── test_goal_service.py     # NEW: Service unit tests
│   └── api/
│       └── test_goals_api.py        # NEW: API integration tests
└── alembic/
    └── versions/
        └── xxx_create_goals_table.py # NEW: Migration file
```

**Modified Files:**
```
packages/backend/
├── app/
│   ├── models/
│   │   ├── __init__.py              # UPDATE: Import Goal model
│   │   └── user.py                  # UPDATE: Add goals relationship
│   └── api/
│       └── v1/
│           └── __init__.py          # UPDATE: Register goals router
└── main.py                           # UPDATE: Include goals router
```

### References

**Source Documents:**
- **Epics File**: `docs/epics.md` (lines 640-682: Story 3.1 requirements)
- **Architecture**: `docs/ARCHITECTURE.md` (PostgreSQL patterns, UUID generation)
- **Story 1.2**: Database schema patterns (UUID, timestamps, foreign keys)
- **Story 1.3**: Clerk authentication integration (user_id extraction)

**Technical Documentation:**
- **FastAPI**: https://fastapi.tiangolo.com/tutorial/sql-databases/
- **SQLAlchemy 2.0**: https://docs.sqlalchemy.org/en/20/orm/quickstart.html
- **Alembic**: https://alembic.sqlalchemy.org/en/latest/tutorial.html
- **Pydantic**: https://docs.pydantic.dev/latest/

---

## Definition of Done

- [ ] ✅ `goals` table created via Alembic migration with all required fields
- [ ] ✅ `Goal` SQLAlchemy model created with enums and relationships
- [ ] ✅ Pydantic schemas created (`GoalCreate`, `GoalUpdate`, `GoalResponse`, `GoalListResponse`)
- [ ] ✅ `GoalService` created with all CRUD methods (create, list, get, update, archive)
- [ ] ✅ API endpoints implemented (`POST`, `GET`, `GET /{id}`, `PATCH`, `DELETE`)
- [ ] ✅ Authorization enforced (users can only access their own goals)
- [ ] ✅ Validation working (422 errors for invalid data)
- [ ] ✅ Soft delete implemented (archive sets status, doesn't delete record)
- [ ] ✅ Pagination implemented for list endpoint
- [ ] ✅ Timestamps auto-update on modifications
- [ ] ✅ Database indexes created for performance
- [ ] ✅ Unit tests created with 80%+ coverage
- [ ] ✅ Integration tests created for all endpoints
- [ ] ✅ All acceptance criteria manually verified
- [ ] ✅ Code follows async SQLAlchemy 2.0 patterns
- [ ] ✅ OpenAPI documentation auto-generated (Swagger UI)
- [ ] ✅ API examples added to `docs/API-TESTING-GUIDE.md`
- [ ] ✅ No secrets committed
- [ ] ✅ Story status updated to `done` in `docs/sprint-status.yaml`

---

## Implementation Notes

### Estimated Timeline

- **Task 1** (Database Migration): 1 hour
- **Task 2** (SQLAlchemy Model): 1 hour
- **Task 3** (Pydantic Schemas): 1 hour
- **Task 4** (Goal Service): 2 hours
- **Task 5** (API Endpoints): 2 hours
- **Task 6** (Unit Tests): 1.5 hours
- **Task 7** (Integration Tests): 1.5 hours
- **Task 8** (Documentation): 0.5 hours

**Total:** ~10.5 hours

### Risk Mitigation

**Risk:** Enum values in PostgreSQL might cause issues with migrations

- **Mitigation**: Use VARCHAR with CHECK constraints instead of PostgreSQL ENUMs for flexibility
- **Impact**: Low (standard pattern, easy to modify)

**Risk:** User deletion might fail due to foreign key constraints

- **Mitigation**: Use CASCADE delete on foreign keys
- **Impact**: Low (handled at database level)

**Risk:** Pagination might perform poorly with large datasets

- **Mitigation**: Index on `(user_id, status, created_at)` for common query patterns
- **Impact**: Low (users unlikely to have >1000 goals)

---

**Last Updated:** 2025-11-18
**Story Status:** drafted
**Next Steps:** Implement tasks 1-8, test all acceptance criteria, mark story ready for dev
