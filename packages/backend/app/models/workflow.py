"""
Workflow models for node-based planning and execution.
Supports complex multi-step processes with parallel and conditional execution.
"""

import uuid
from datetime import datetime
from enum import Enum as PyEnum

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Enum,
    ForeignKey,
    Integer,
    String,
    Text,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship

from app.db.base import Base


class WorkflowStatus(str, PyEnum):
    """Workflow lifecycle states."""

    DRAFT = "draft"  # Being created/edited
    PENDING_APPROVAL = "pending_approval"  # Waiting for user approval
    APPROVED = "approved"  # User approved, ready to execute
    EXECUTING = "executing"  # Currently running
    PAUSED = "paused"  # Execution paused
    COMPLETED = "completed"  # Successfully finished
    FAILED = "failed"  # Execution failed
    CANCELLED = "cancelled"  # User cancelled


class NodeType(str, PyEnum):
    """Types of workflow nodes."""

    TASK = "task"  # Regular execution task
    DECISION = "decision"  # Decision point (if/else)
    PARALLEL_GROUP = "parallel_group"  # Group of parallel tasks
    CONDITIONAL = "conditional"  # Conditional execution
    INPUT = "input"  # User input required
    OUTPUT = "output"  # Output/result node
    VERIFICATION = "verification"  # Verification/validation step


class NodeStatus(str, PyEnum):
    """Node execution states."""

    PENDING = "pending"  # Not started
    READY = "ready"  # Dependencies met, ready to run
    IN_PROGRESS = "in_progress"  # Currently executing
    COMPLETED = "completed"  # Successfully finished
    FAILED = "failed"  # Execution failed
    SKIPPED = "skipped"  # Skipped due to conditions
    BLOCKED = "blocked"  # Blocked by dependencies


class EdgeType(str, PyEnum):
    """Types of edges between nodes."""

    SEQUENTIAL = "sequential"  # Run one after another
    PARALLEL = "parallel"  # Can run simultaneously
    CONDITIONAL = "conditional"  # Conditional transition


class ExecutionStatus(str, PyEnum):
    """Workflow execution states."""

    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"


class Workflow(Base):
    """
    Workflow represents a complete plan/process.
    Can be user-created or LLM-generated.
    """

    __tablename__ = "workflows"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    name = Column(String(255), nullable=False, comment="Workflow name")
    description = Column(Text, comment="Detailed workflow description")
    status = Column(
        Enum(WorkflowStatus),
        default=WorkflowStatus.DRAFT,
        nullable=False,
        index=True,
    )
    llm_generated = Column(
        Boolean,
        default=False,
        comment="Whether workflow was auto-generated by LLM",
    )
    metadata = Column(
        JSONB,
        comment="Additional workflow metadata (tags, priority, etc.)",
    )
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    user = relationship("User", backref="workflows")
    nodes = relationship(
        "WorkflowNode",
        back_populates="workflow",
        cascade="all, delete-orphan",
        order_by="WorkflowNode.created_at",
    )
    edges = relationship(
        "WorkflowEdge",
        back_populates="workflow",
        cascade="all, delete-orphan",
    )
    executions = relationship(
        "WorkflowExecution",
        back_populates="workflow",
        cascade="all, delete-orphan",
        order_by="WorkflowExecution.created_at.desc()",
    )

    def __repr__(self) -> str:
        return f"<Workflow(id={self.id}, name={self.name}, status={self.status})>"


class WorkflowNode(Base):
    """
    Individual step/task in a workflow.
    Represents a single unit of work or decision point.
    """

    __tablename__ = "workflow_nodes"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    workflow_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflows.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    name = Column(String(255), nullable=False, comment="Node name")
    description = Column(Text, comment="Detailed node description")
    node_type = Column(
        Enum(NodeType),
        default=NodeType.TASK,
        nullable=False,
        comment="Type of node",
    )
    status = Column(
        Enum(NodeStatus),
        default=NodeStatus.PENDING,
        nullable=False,
        index=True,
    )
    tool_name = Column(
        String(100),
        comment="Name of tool/function to execute (e.g., 'fetch_data', 'analyze')",
    )
    input_schema = Column(
        JSONB,
        comment="Expected input parameters schema",
    )
    output_data = Column(
        JSONB,
        comment="Execution results and outputs",
    )
    can_run_parallel = Column(
        Boolean,
        default=False,
        comment="Whether this node can run in parallel with others",
    )
    position = Column(
        JSONB,
        comment="UI visualization position {x: number, y: number}",
    )
    retry_count = Column(
        Integer,
        default=0,
        comment="Number of execution attempts",
    )
    max_retries = Column(
        Integer,
        default=3,
        comment="Maximum retry attempts",
    )
    error_message = Column(
        Text,
        comment="Error details if node failed",
    )
    started_at = Column(DateTime(timezone=True), comment="When node execution started")
    completed_at = Column(DateTime(timezone=True), comment="When node execution completed")
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    workflow = relationship("Workflow", back_populates="nodes")
    outgoing_edges = relationship(
        "WorkflowEdge",
        foreign_keys="WorkflowEdge.source_node_id",
        back_populates="source_node",
        cascade="all, delete-orphan",
    )
    incoming_edges = relationship(
        "WorkflowEdge",
        foreign_keys="WorkflowEdge.target_node_id",
        back_populates="target_node",
        cascade="all, delete-orphan",
    )

    def __repr__(self) -> str:
        return f"<WorkflowNode(id={self.id}, name={self.name}, type={self.node_type}, status={self.status})>"


class WorkflowEdge(Base):
    """
    Connection between workflow nodes.
    Defines dependencies and execution flow.
    """

    __tablename__ = "workflow_edges"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    workflow_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflows.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    source_node_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflow_nodes.id", ondelete="CASCADE"),
        nullable=False,
        comment="Starting node",
    )
    target_node_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflow_nodes.id", ondelete="CASCADE"),
        nullable=False,
        comment="Destination node",
    )
    edge_type = Column(
        Enum(EdgeType),
        default=EdgeType.SEQUENTIAL,
        nullable=False,
        comment="Type of connection",
    )
    condition = Column(
        JSONB,
        comment="Conditional logic for conditional edges {type: 'if', expression: '...', operator: '==', value: ...}",
    )
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)

    # Relationships
    workflow = relationship("Workflow", back_populates="edges")
    source_node = relationship(
        "WorkflowNode",
        foreign_keys=[source_node_id],
        back_populates="outgoing_edges",
    )
    target_node = relationship(
        "WorkflowNode",
        foreign_keys=[target_node_id],
        back_populates="incoming_edges",
    )

    def __repr__(self) -> str:
        return f"<WorkflowEdge(id={self.id}, type={self.edge_type}, {self.source_node_id} -> {self.target_node_id})>"


class WorkflowExecution(Base):
    """
    Tracks workflow execution state and history.
    One workflow can have multiple executions.
    """

    __tablename__ = "workflow_executions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    workflow_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflows.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
    )
    status = Column(
        Enum(ExecutionStatus),
        default=ExecutionStatus.RUNNING,
        nullable=False,
        index=True,
    )
    current_node_id = Column(
        UUID(as_uuid=True),
        ForeignKey("workflow_nodes.id", ondelete="SET NULL"),
        comment="Currently executing node",
    )
    execution_context = Column(
        JSONB,
        default={},
        comment="Shared data and state between nodes",
    )
    started_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    completed_at = Column(DateTime(timezone=True), comment="When execution finished")
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    workflow = relationship("Workflow", back_populates="executions")
    current_node = relationship("WorkflowNode", foreign_keys=[current_node_id])

    def __repr__(self) -> str:
        return f"<WorkflowExecution(id={self.id}, workflow_id={self.workflow_id}, status={self.status})>"
